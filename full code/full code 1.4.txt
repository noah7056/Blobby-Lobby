server.js:

const express = require('express');
const app = express();
const http = require('http').createServer(app);
const io = require('socket.io')(http);
const PORT = process.env.PORT || 3000;

app.use(express.static('public'));

const players = {};
const chatHistory = [];
const sprays = [];

// Canvas dimensions and player size
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 600;
const PLAYER_RADIUS = 20;

// Define the petSpeed variable (this was missing)
const petSpeed = 1.5;

function generateRandomUsername() {
  const prefixes = ['Player', 'User', 'Gamer', 'Blob', 'Guest', 'Casual'];
  const randomNum = Math.floor(1000 + Math.random() * 9000); // 4 digit number
  return `${prefixes[Math.floor(Math.random() * prefixes.length)]}${randomNum}`;
}

io.on('connection', (socket) => {
  console.log('A user connected:', socket.id);

  socket.on('newPlayer', (data) => {
    // Use provided username or generate a random one
    const username = data.username || generateRandomUsername();
    
    players[socket.id] = {
      x: Math.floor(Math.random() * (CANVAS_WIDTH - 2 * PLAYER_RADIUS)) + PLAYER_RADIUS,
      y: Math.floor(Math.random() * (CANVAS_HEIGHT - 2 * PLAYER_RADIUS)) + PLAYER_RADIUS,
      color: data.color,
      username: username,
      lastDirection: 'right', // Default direction
      pet: data.pet || null, // Pet info
      petPosition: {
        x: Math.floor(Math.random() * (CANVAS_WIDTH - 2 * PLAYER_RADIUS)) + PLAYER_RADIUS,
        y: Math.floor(Math.random() * (CANVAS_HEIGHT - 2 * PLAYER_RADIUS)) + PLAYER_RADIUS
      }
    };
    console.log(`New player joined: ${username} (${data.color})`);
    socket.emit('chatHistory', chatHistory);
    
    socket.emit('allSprays', sprays.filter(spray => {
      // Only send sprays that haven't expired
      return Date.now() - spray.timestamp < 10000;
    }));
  });

  socket.on('updatePlayer', (data) => {
    if (players[socket.id]) {
      let changes = [];
      
      if (data.color) {
        players[socket.id].color = data.color;
        changes.push(`color to ${data.color}`);
      }
      
      if (data.username) {
        players[socket.id].username = data.username;
        changes.push(`name to ${data.username}`);
      }
      
      if (data.pet !== undefined) {
        players[socket.id].pet = data.pet;
        changes.push(`pet to ${data.pet ? data.pet : 'none'}`);
      }
      
      console.log(`Player ${socket.id} updated: ${changes.join(', ')}`);
    }
  });

  socket.on('move', (dir) => {
    const speed = 3;
    if (players[socket.id]) {
      let newX = players[socket.id].x;
      let newY = players[socket.id].y;
      
      if (dir === 'left') {
        newX -= speed;
        players[socket.id].lastDirection = 'left';
      }
      if (dir === 'right') {
        newX += speed;
        players[socket.id].lastDirection = 'right';
      }
      if (dir === 'up') newY -= speed;
      if (dir === 'down') newY += speed;

      // Fixed boundary checking accounting for player radius
      newX = Math.max(PLAYER_RADIUS, Math.min(newX, CANVAS_WIDTH - PLAYER_RADIUS));
      newY = Math.max(PLAYER_RADIUS, Math.min(newY, CANVAS_HEIGHT - PLAYER_RADIUS));
      
      // Check for collisions with other players
      let canMove = true;
      const COLLISION_THRESHOLD = PLAYER_RADIUS * 1.2; // Allow some overlap
      
      for (let id in players) {
        if (id !== socket.id) {
          const otherPlayer = players[id];
          const distance = Math.hypot(newX - otherPlayer.x, newY - otherPlayer.y);
          
          if (distance < COLLISION_THRESHOLD) {
            // Allow some overlap but still push players apart
            const pushFactor = 0.3;
            const angle = Math.atan2(newY - otherPlayer.y, newX - otherPlayer.x);
            
            // Move both players slightly
            newX = players[socket.id].x + Math.cos(angle) * pushFactor;
            newY = players[socket.id].y + Math.sin(angle) * pushFactor;
            
            otherPlayer.x -= Math.cos(angle) * pushFactor;
            otherPlayer.y -= Math.sin(angle) * pushFactor;
            
            // Apply boundary check to other player too
            otherPlayer.x = Math.max(PLAYER_RADIUS, Math.min(otherPlayer.x, CANVAS_WIDTH - PLAYER_RADIUS));
            otherPlayer.y = Math.max(PLAYER_RADIUS, Math.min(otherPlayer.y, CANVAS_HEIGHT - PLAYER_RADIUS));
            
            break;
          }
        }
      }
      
      players[socket.id].x = newX;
      players[socket.id].y = newY;
      
      // Update pet position with lag
if (players[socket.id].pet) {
  const playerPos = { x: players[socket.id].x, y: players[socket.id].y };
  const petPos = players[socket.id].petPosition;
  
  // Calculate direction from pet to player
  const dx = playerPos.x - petPos.x;
  const dy = playerPos.y - petPos.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  
  // Only move pet if it's far enough from player
  if (distance > 50) {
    // Normalize direction and apply pet speed
    const normalizedDx = dx / distance;
    const normalizedDy = dy / distance;
    
    petPos.x += normalizedDx * petSpeed;
    petPos.y += normalizedDy * petSpeed;
  }
}
    }
  });

  socket.on('chatMessage', (msg) => {
    let username = players[socket.id]?.username;
    if (!username) username = 'Anonymous';
    const message = { username, text: msg };
    chatHistory.push(message);
    if (chatHistory.length > 50) chatHistory.shift();
    io.emit('chatMessage', message);
  });

  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);
    delete players[socket.id];
  });

  setInterval(() => {
    io.emit('state', players);
  }, 1000 / 60);
  
  // Add this after the other setInterval for state updates
setInterval(() => {
  // Update all pets' positions
  for (let id in players) {
    const player = players[id];
    if (player.pet) {
      const playerPos = { x: player.x, y: player.y };
      const petPos = player.petPosition;
      
      // Calculate direction from pet to player
      const dx = playerPos.x - petPos.x;
      const dy = playerPos.y - petPos.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Always move pet towards player until it's within 40 units
      if (distance > 40) {
        // Normalize direction and apply pet speed
        const normalizedDx = dx / distance;
        const normalizedDy = dy / distance;
        
        petPos.x += normalizedDx * petSpeed;
        petPos.y += normalizedDy * petSpeed;
      }
    }
  }
}, 1000 / 30); // Update pet positions 30 times per second
  
  socket.on('addSpray', (data) => {
    if (players[socket.id]) {
      const spray = {
        x: players[socket.id].x,
        y: players[socket.id].y,
        emoji: data.emoji,
        playerId: socket.id,
        timestamp: Date.now()
      };
      
      sprays.push(spray);
      io.emit('newSpray', spray);
      
      // Remove spray after 10 seconds
      setTimeout(() => {
        const index = sprays.findIndex(s => 
          s.playerId === spray.playerId && 
          s.timestamp === spray.timestamp
        );
        
        if (index !== -1) {
          sprays.splice(index, 1);
        }
      }, 10000);
    }
  });
});

http.listen(PORT, '0.0.0.0', () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});

public/client.js:

const socket = io();
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const previewCanvas = document.getElementById('blobPreview');
const previewCtx = previewCanvas.getContext('2d');
let keys = {};
let playerColor = getRandomColor();
let username = generateRandomUsername();
let lastPositions = {}; // Store previous positions for particles
let particles = []; // Array to store all particles
let currentlyPlaying = false; // Flag to check if game is active
let playerAnimations = {}; // Store animation state for each player
let sprays = []; // Array to store all active sprays
let selectedEmoji = null;
let selectedPet = null;

// Preload pet images
const petImages = {
  amongus: new Image(),
  cutecreeper: new Image(),
  ducky: new Image(),
  pusheen: new Image(),
  wheatleyportal2: new Image()
};

// Set image sources
petImages.amongus.src = 'assets/amongus.png';
petImages.cutecreeper.src = 'assets/cutecreeper.png';
petImages.ducky.src = 'assets/ducky.png';
petImages.pusheen.src = 'assets/pusheen.png';
petImages.wheatleyportal2.src = 'assets/wheatleyportal2.png';

// Get DOM elements for customization
const customizeBtn = document.getElementById('customizeBtn');
const customizeMenu = document.getElementById('customizeMenu');
const nameInput = document.getElementById('nameInput');
const namePreview = document.getElementById('namePreview');
const applyCustomization = document.getElementById('applyCustomization');
const closeCustomize = document.getElementById('closeCustomize');
const colorSwatches = document.querySelectorAll('.color-swatch');
const startForm = document.getElementById('startForm');
const sprayBtn = document.getElementById('sprayBtn'); // Added missing reference to sprayBtn
let selectedColor = null;
let newUsername = null;

function getRandomColor() {
  const colors = ['red', 'blue', 'green', 'purple', 'orange', 'pink', 'cyan', 'yellow'];
  return colors[Math.floor(Math.random() * colors.length)];
}

function generateRandomUsername() {
  const prefixes = ['Player', 'User', 'Gamer', 'Blob', 'Guest', 'Casual'];
  const randomNum = Math.floor(1000 + Math.random() * 9000); // 4 digit number
  return `${prefixes[Math.floor(Math.random() * prefixes.length)]}${randomNum}`;
}

// Particle class
class Particle {
  constructor(x, y, color) {
    this.x = x;
    this.y = y;
    this.size = Math.random() * 3 + 2;
    this.color = color;
    this.speedX = Math.random() * 1 - 0.5;
    this.speedY = Math.random() * 1 - 0.5;
    this.life = 30; // How long the particle lives (frames)
  }

  update() {
    this.x += this.speedX;
    this.y += this.speedY;
    this.life--;
    if (this.life > 0) {
      this.size *= 0.95; // Particles get smaller over time
    }
  }

  draw() {
    ctx.fillStyle = this.color;
    ctx.globalAlpha = this.life / 30;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

// Create particles when player moves
function createParticles(player, id) {
  if (!lastPositions[id]) {
    lastPositions[id] = { x: player.x, y: player.y };
    return;
  }

  // Only create particles if the player moved a meaningful distance
  const distance = Math.hypot(player.x - lastPositions[id].x, player.y - lastPositions[id].y);
  if (distance > 1) {
    for (let i = 0; i < 2; i++) {
      particles.push(new Particle(player.x, player.y, player.color));
    }
    lastPositions[id] = { x: player.x, y: player.y };
    
    // Initialize animation state if it doesn't exist
    if (!playerAnimations[id]) {
      playerAnimations[id] = {
        pulsating: false,
        scale: 1,
        direction: -1, // Start by getting smaller
        speed: 0.04
      };
    } else {
      // Just enable pulsation but don't reset other properties
      playerAnimations[id].pulsating = false;
      // Only adjust direction if needed, don't reset speed
      // This prevents increased speed when moving rapidly
    }
  } else {
    // Player is not moving, gradually stop pulsating
    if (playerAnimations[id] && playerAnimations[id].pulsating) {
      // Reset scale towards 1 when stopped
      if (Math.abs(playerAnimations[id].scale - 1) < 0.02) {
        playerAnimations[id].scale = 1;
        playerAnimations[id].pulsating = false;
      } else {
        // Move scale back to 1 gradually
        playerAnimations[id].scale += (1 - playerAnimations[id].scale) * 0.1;
      }
    }
  }
}

// Draw blob in preview canvas
function updatePreview() {
  previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
  
  // Draw blob
  previewCtx.fillStyle = selectedColor || playerColor;
  previewCtx.beginPath();
  previewCtx.arc(previewCanvas.width / 2, previewCanvas.height / 2, 20, 0, Math.PI * 2);
  previewCtx.fill();
  
  // Draw shadow
  /*
  previewCtx.fillStyle = 'rgba(0,0,0,0.3)';
  previewCtx.beginPath();
  previewCtx.ellipse(previewCanvas.width / 2, previewCanvas.height / 2 + 18, 18, 8, 0, 0, Math.PI * 2);
  previewCtx.fill();
  */
  
  // Update name preview
  namePreview.textContent = newUsername || username;
}

// Initialize color swatches
function initializeColorSwatches() {
  // Add click events to color swatches
  colorSwatches.forEach(swatch => {
    swatch.addEventListener('click', () => {
      // Remove selected class from all swatches
      colorSwatches.forEach(s => s.classList.remove('selected'));
      // Add selected class to clicked swatch
      swatch.classList.add('selected');
      // Update selected color
      selectedColor = swatch.dataset.color;
      // Update preview
      updatePreview();
    });
    
    // If this swatch matches the current playerColor, select it
    if (swatch.dataset.color === playerColor) {
      swatch.classList.add('selected');
      selectedColor = playerColor;
    }
  });
  
  // Initialize name input events
  nameInput.value = username;
  nameInput.addEventListener('input', () => {
    newUsername = nameInput.value.trim() || username;
    updatePreview();
  });
  
  // Initial preview
  updatePreview();
}

// Initialize customization menu
function initializeCustomizationMenu() {
  // Show customize button when game starts
  customizeBtn.addEventListener('click', () => {
    customizeMenu.style.display = 'block';
    
    // Ensure the correct color is selected
    colorSwatches.forEach(s => s.classList.remove('selected'));
    const currentSwatch = Array.from(colorSwatches).find(s => s.dataset.color === playerColor);
    if (currentSwatch) {
      currentSwatch.classList.add('selected');
    }
    
	// pet selection
const petItems = document.querySelectorAll('.pet-item');
petItems.forEach(item => {
  item.addEventListener('click', () => {
    // Remove selected class from all pet items
    petItems.forEach(p => p.classList.remove('selected'));
    // Add selected class to clicked item
    item.classList.add('selected');
    // Update selected pet
    selectedPet = item.dataset.pet === 'none' ? null : item.dataset.pet;
    // Update preview to show the pet
    updatePreview();
  });
});
if (currentPet) {
      currentPet.classList.add('selected');
    }
    
    // Update name input
    nameInput.value = username;
    newUsername = username;
    selectedColor = playerColor;
    updatePreview();
  });
  
  // Close button functionality
  closeCustomize.addEventListener('click', () => {
    customizeMenu.style.display = 'none';
  });
  
  // Apply changes button
  applyCustomization.addEventListener('click', () => {
    let changed = false;
    
    if (selectedColor && selectedColor !== playerColor) {
      playerColor = selectedColor;
      changed = true;
    }
    
    if (newUsername && newUsername !== username && newUsername.trim() !== '') {
      username = newUsername;
      changed = true;
    }
    
    // Check if pet changed
    if (selectedPet !== undefined) {
      changed = true;
    }
    
    if (changed) {
      socket.emit('updatePlayer', { color: playerColor, username: username, pet: selectedPet });
    }
    
    customizeMenu.style.display = 'none';
  });
  
  // Add pet selection
  const petItems = document.querySelectorAll('.pet-item');
  petItems.forEach(item => {
    item.addEventListener('click', () => {
      // Remove selected class from all pet items
      petItems.forEach(p => p.classList.remove('selected'));
      // Add selected class to clicked item
      item.classList.add('selected');
      // Update selected pet
      selectedPet = item.dataset.pet === 'none' ? null : item.dataset.pet;
    });
  });
}

startForm.addEventListener('submit', (e) => {
  e.preventDefault();
  socket.emit('newPlayer', { username, color: playerColor, pet: selectedPet });
  startForm.style.display = 'none';
  
  // Show the customize button when the game starts
  customizeBtn.style.display = 'block';
  sprayBtn.style.display = 'block';
  currentlyPlaying = true;
});

window.addEventListener('keydown', (e) => keys[e.key] = true);
window.addEventListener('keyup', (e) => keys[e.key] = false);

function gameLoop() {
  if (currentlyPlaying) {
    if (keys['a'] || keys['ArrowLeft']) socket.emit('move', 'left');
    if (keys['d'] || keys['ArrowRight']) socket.emit('move', 'right');
    if (keys['w'] || keys['ArrowUp']) socket.emit('move', 'up');
    if (keys['s'] || keys['ArrowDown']) socket.emit('move', 'down');
  }
  
  // Update and remove dead particles
  particles.forEach((particle, index) => {
    particle.update();
    if (particle.life <= 0) {
      particles.splice(index, 1);
    }
  });
  
  requestAnimationFrame(gameLoop);
}

socket.on('state', (players) => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw particles behind players
  particles.forEach(particle => {
    particle.draw();
  });
  
  // Draw sprays before players
  sprays.forEach((spray, index) => {
    if (spray.isExpired()) {
      sprays.splice(index, 1);
    } else {
      spray.draw();
    }
  });
  
  for (let id in players) {
    const p = players[id];
    
    // Draw pet if player has one
    if (p.pet && p.pet !== 'none') {
      // Calculate pet position - use server-provided position
      let petX = p.petPosition ? p.petPosition.x : p.x - 30;
      let petY = p.petPosition ? p.petPosition.y : p.y;
      
      // Draw pet image
      const petImg = petImages[p.pet];
      if (petImg && petImg.complete) {
        // Calculate size - make it proportional but smaller than player
        const petSize = 30; // base size
        const aspectRatio = petImg.width / petImg.height;
        let petWidth, petHeight;
        
        if (aspectRatio > 1) {
          // Image is wider than tall
          petWidth = petSize;
          petHeight = petSize / aspectRatio;
        } else {
          // Image is taller than wide
          petWidth = petSize * aspectRatio;
          petHeight = petSize;
        }
        
        // Draw the image centered on the pet position
        ctx.drawImage(
          petImg,
          petX - petWidth / 2,
          petY - petHeight / 2,
          petWidth,
          petHeight
        );
      }
    }
	
	// show preview of the pet
function updatePetPreview() {
  // Only show pet if one is selected
  if (selectedPet) {
    const petImg = petImages[selectedPet];
    if (petImg && petImg.complete) {
      // Calculate size - make it proportional but smaller than player
      const petSize = 20; // smaller for preview
      const aspectRatio = petImg.width / petImg.height;
      let petWidth, petHeight;
      
      if (aspectRatio > 1) {
        // Image is wider than tall
        petWidth = petSize;
        petHeight = petSize / aspectRatio;
      } else {
        // Image is taller than wide
        petWidth = petSize * aspectRatio;
        petHeight = petSize;
      }
      
      // Draw the pet to the left of the player
      previewCtx.drawImage(
        petImg,
        (previewCanvas.width / 2) - 30 - petWidth / 2,
        (previewCanvas.height / 2) - petHeight / 2,
        petWidth,
        petHeight
      );
    }
  }
}
    
    // Create particles
    createParticles(p, id);
    
    // Get animation state for this player
    const anim = playerAnimations[id] || { scale: 1, pulsating: false };
    
    // Update pulsation if player is moving
	/*
    if (anim.pulsating) {
      anim.scale += anim.direction * anim.speed;
      
      // Reverse direction when reaching scale limits
      if (anim.scale <= 0.85) {
        anim.scale = 0.85;
        anim.direction = 1;
      } else if (anim.scale >= 1.1) {
        anim.scale = 1.1;
        anim.direction = -1;
      }
    }
	*/
    
    // Draw isometric blob
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.scale(anim.scale, anim.scale * 0.75); // Scale Y less for isometric effect
    ctx.arc(0, 0, 20, 0, Math.PI * 2);
    ctx.fill();
    
    // Remove shadow and simplify eye
	/*
    ctx.fillStyle = 'black';
    ctx.beginPath();
    const eyeX = p.lastDirection === 'right' ? 8 : -8;
    ctx.arc(eyeX, -5, 4, 0, Math.PI * 2);
    ctx.fill();
	*/
    
    ctx.restore();
    
    // Draw player name (not affected by scale)
    ctx.fillStyle = 'white';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(p.username || 'Anonymous', p.x, p.y - 30);
  }
});

// Spray class to manage sprays
class Spray {
  constructor(x, y, emoji, playerId) {
    this.x = x;
    this.y = y;
    this.emoji = emoji;
    this.playerId = playerId;
    this.createdAt = Date.now();
    this.lifespan = 10000; // 10 seconds in milliseconds
  }
  
  isExpired() {
    return Date.now() - this.createdAt > this.lifespan;
  }
  
  draw() {
    // Calculate opacity based on remaining life
    const remainingLife = 1 - (Date.now() - this.createdAt) / this.lifespan;
    
    ctx.save();
    ctx.globalAlpha = remainingLife;
    ctx.font = '24px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(this.emoji, this.x, this.y + 30); // Position below player
    ctx.restore();
  }
}

// initialize spray functionality
function initializeSprayFeature() {
  const sprayBtn = document.getElementById('sprayBtn');
  const sprayMenu = document.getElementById('sprayMenu');
  const closeSprayMenu = document.getElementById('closeSprayMenu');
  const sprayItems = document.querySelectorAll('.spray-item');
  
  // Show spray menu when button is clicked
  sprayBtn.addEventListener('click', () => {
    sprayMenu.style.display = 'block';
  });
  
  // Close spray menu when close button is clicked
  closeSprayMenu.addEventListener('click', () => {
    sprayMenu.style.display = 'none';
  });
  
  // Handle spray item selection
  sprayItems.forEach(item => {
    item.addEventListener('click', () => {
      selectedEmoji = item.dataset.emoji;
      sprayMenu.style.display = 'none';
      
      // Emit spray action to server
      socket.emit('addSpray', { emoji: selectedEmoji });
    });
  });
}

// socket event listeners for sprays
socket.on('newSpray', (data) => {
  sprays.push(new Spray(data.x, data.y, data.emoji, data.playerId));
});

socket.on('allSprays', (sprayData) => {
  sprays = [];
  sprayData.forEach(data => {
    sprays.push(new Spray(data.x, data.y, data.emoji, data.playerId));
  });
});

// Chat logic
const chatForm = document.getElementById('chatForm');
const chatInput = document.getElementById('chatInput');
const messages = document.getElementById('messages');

chatForm.addEventListener('submit', (e) => {
  e.preventDefault();
  if (chatInput.value.trim()) {
    socket.emit('chatMessage', chatInput.value);
    chatInput.value = '';
  }
});

socket.on('chatMessage', (msg) => {
  const div = document.createElement('div');
  div.textContent = `${msg.username}: ${msg.text}`;
  messages.appendChild(div);
  messages.scrollTop = messages.scrollHeight;
});

socket.on('chatHistory', (history) => {
  messages.innerHTML = '';
  history.forEach((msg) => {
    const div = document.createElement('div');
    div.textContent = `${msg.username}: ${msg.text}`;
    messages.appendChild(div);
  });
  messages.scrollTop = messages.scrollHeight;
});

// Initialize the game
function init() {
  initializeColorSwatches();
  initializeCustomizationMenu();
  initializeSprayFeature();
  requestAnimationFrame(gameLoop);
}

// Start everything when the page loads
window.addEventListener('load', init);

public/index.html:

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Blobby Lobby</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <h1>üåà Blobby Lobby üåà</h1>
  <form id="startForm">
    <button type="submit">Join Lobby</button>
  </form>
  
	<button id="customizeBtn" class="action-button">Customize Blob</button>
	<button id="sprayBtn" class="action-button">Use Spray</button>
  
  <div id="gameContainer">
    <canvas id="game" width="800" height="600"></canvas>
    
    <div id="customizeMenu">
      <h3>Customize Your Blob</h3>
      
      <div class="menu-section">
        <label for="nameInput">Change Name:</label>
        <input type="text" id="nameInput" placeholder="Enter new name">
      </div>
      
      <div class="menu-section">
        <label>Choose Color:</label>
        <div class="color-options">
          <div class="color-swatch" data-color="red" style="background-color: red;"></div>
          <div class="color-swatch" data-color="blue" style="background-color: blue;"></div>
          <div class="color-swatch" data-color="green" style="background-color: green;"></div>
          <div class="color-swatch" data-color="purple" style="background-color: purple;"></div>
          <div class="color-swatch" data-color="orange" style="background-color: orange;"></div>
          <div class="color-swatch" data-color="pink" style="background-color: pink;"></div>
          <div class="color-swatch" data-color="cyan" style="background-color: cyan;"></div>
          <div class="color-swatch" data-color="yellow" style="background-color: yellow;"></div>
        </div>
      </div>
	  
	  <div class="menu-section">
  <label>Choose Pet:</label>
  <div class="pet-options">
    <div class="pet-item" data-pet="none">None</div>
    <div class="pet-item" data-pet="amongus">Among Us</div>
    <div class="pet-item" data-pet="cutecreeper">Creeper</div>
    <div class="pet-item" data-pet="ducky">Ducky</div>
    <div class="pet-item" data-pet="pusheen">Pusheen</div>
    <div class="pet-item" data-pet="wheatleyportal2">Wheatley</div>
  </div>
</div>
      
      <div class="preview-container">
        <div>Preview:</div>
        <canvas id="blobPreview" width="100" height="100"></canvas>
        <div id="namePreview">Player123</div>
      </div>
      
      <button id="applyCustomization" class="action-button">Apply Changes</button>
      <button id="closeCustomize" class="action-button secondary">Close</button>
    </div>
  </div>
  
  <div id="sprayMenu">
  <h3>Choose a Spray</h3>
  <div class="spray-options">
    <div class="spray-item" data-emoji="üòÄ">üòÄ</div>
    <div class="spray-item" data-emoji="üëç">üëç</div>
    <div class="spray-item" data-emoji="‚ù§Ô∏è">‚ù§Ô∏è</div>
    <div class="spray-item" data-emoji="üî•">üî•</div>
    <div class="spray-item" data-emoji="üòé">üòé</div>
    <div class="spray-item" data-emoji="ü§£">ü§£</div>
    <div class="spray-item" data-emoji="üëã">üëã</div>
    <div class="spray-item" data-emoji="üéÆ">üéÆ</div>
  </div>
  <button id="closeSprayMenu" class="action-button secondary">Close</button>
</div>
  
  <div id="chat">
    <div id="messages"></div>
    <form id="chatForm">
      <input type="text" id="chatInput" placeholder="Type a message..." />
      <button type="submit">Send</button>
    </form>
  </div>
  
  <script src="/socket.io/socket.io.js"></script>
  <script src="client.js"></script>
</body>
</html>

public/style.css:

body {
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  background: #0D1B2A;
  font-family: sans-serif;
  color: #E0E1DD;
}
canvas {
  border: 2px solid #778DA9;
  background: #1B263B;
  margin-top: 20px;
}
#startForm {
  margin-top: 20px;
}
input[type="text"] {
  padding: 8px;
  border-radius: 4px;
  border: none;
  margin-right: 8px;
  background-color: #E0E1DD;
  color: #0D1B2A;
}
button[type="submit"] {
  padding: 8px 16px;
  border-radius: 4px;
  border: none;
  background-color: #415A77;
  color: #E0E1DD;
  cursor: pointer;
  transition: background-color 0.2s;
}
button[type="submit"]:hover {
  background-color: #778DA9;
}
#chat {
  width: 800px;
  margin-top: 20px;
}
#messages {
  height: 150px;
  overflow-y: auto;
  background: #1B263B;
  border: 1px solid #415A77;
  padding: 10px;
  border-radius: 4px;
  margin-bottom: 10px;
  word-wrap: break-word;
  color: white;
}
#chatForm input[type="text"] {
  width: 70%;
  padding: 8px;
  border-radius: 4px;
  border: none;
  margin-right: 8px;
  background-color: #E0E1DD;
  color: #0D1B2A;
}
#chatForm button {
  padding: 8px 16px;
  border-radius: 4px;
  border: none;
  background-color: #415A77;
  color: #E0E1DD;
  cursor: pointer;
  transition: background-color 0.2s;
}
#chatForm button:hover {
  background-color: #778DA9;
}

/* Game container styles */
#gameContainer {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Customize button - updated position */
#customizeBtn {
  position: static; /* Change from absolute to static */
  margin: 10px 0; /* Add margin top and bottom */
  background-color: #415A77;
  color: #E0E1DD;
  border: none;
  border-radius: 4px;
  padding: 8px 12px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.2s;
  display: none; /* Hidden by default until game starts */
  width: 800px; /* Match the width of the game canvas */
}

#customizeBtn:hover {
  background-color: #778DA9;
}

/* Customization menu */
#customizeMenu {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #1B263B;
  border: 2px solid #415A77;
  border-radius: 8px;
  padding: 20px;
  z-index: 100;
  width: 300px;
  display: none; /* Hidden by default */
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
}

#customizeMenu h3 {
  text-align: center;
  margin-top: 0;
  color: #E0E1DD;
  margin-bottom: 15px;
}

.menu-section {
  margin-bottom: 15px;
}

.menu-section label {
  display: block;
  margin-bottom: 8px;
  color: #E0E1DD;
  font-weight: bold;
}

#nameInput {
  width: calc(100% - 16px);
  padding: 8px;
  border-radius: 4px;
  border: none;
  background-color: #E0E1DD;
  color: #0D1B2A;
  margin-bottom: 5px;
}

.color-options {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
  margin-top: 8px;
}

.color-swatch {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  border: 2px solid transparent;
}

.color-swatch:hover {
  transform: scale(1.1);
}

.color-swatch.selected {
  border: 2px solid white;
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
}

.preview-container {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  margin: 15px 0;
  background-color: rgba(13, 27, 42, 0.5);
  padding: 10px;
  border-radius: 8px;
}

#blobPreview {
  background-color: #0D1B2A;
  border-radius: 4px;
  margin: 5px 0;
}

#namePreview {
  color: white;
  font-size: 14px;
  margin-top: 5px;
  text-align: center;
}

.action-button {
  padding: 8px 16px;
  border-radius: 4px;
  border: none;
  width: 100%;
  margin-top: 10px;
  cursor: pointer;
  transition: background-color 0.2s;
  font-weight: bold;
}

#applyCustomization {
  background-color: #415A77;
  color: #E0E1DD;
}

#applyCustomization:hover {
  background-color: #778DA9;
}

#closeCustomize {
  background-color: #1B263B;
  border: 1px solid #415A77;
  color: #E0E1DD;
}

#closeCustomize:hover {
  background-color: #28374F;
}

.secondary {
  margin-top: 5px;
}

/* Spray button styles */
#sprayBtn {
  position: static;
  margin: 10px 0;
  background-color: #415A77;
  color: #E0E1DD;
  border: none;
  border-radius: 4px;
  padding: 8px 12px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.2s;
  display: none; /* Hidden by default until game starts */
  width: 800px; /* Match the width of the game canvas */
}

#sprayBtn:hover {
  background-color: #778DA9;
}

/* Spray menu */
#sprayMenu {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #1B263B;
  border: 2px solid #415A77;
  border-radius: 8px;
  padding: 20px;
  z-index: 100;
  width: 300px;
  display: none; /* Hidden by default */
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
}

#sprayMenu h3 {
  text-align: center;
  margin-top: 0;
  color: #E0E1DD;
  margin-bottom: 15px;
}

.spray-options {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
  margin-bottom: 15px;
}

.spray-item {
  width: 50px;
  height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: rgba(65, 90, 119, 0.5);
  border-radius: 8px;
  cursor: pointer;
  font-size: 24px;
  transition: transform 0.2s, background-color 0.2s;
}

.spray-item:hover {
  transform: scale(1.1);
  background-color: rgba(65, 90, 119, 0.8);
}

.pet-options {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
  margin-top: 8px;
}

.pet-item {
  width: 60px;
  height: 40px;
  border-radius: 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: rgba(65, 90, 119, 0.5);
  color: #E0E1DD;
  transition: transform 0.2s, background-color 0.2s;
  font-size: 12px;
  text-align: center;
}

.pet-item:hover {
  transform: scale(1.1);
  background-color: rgba(65, 90, 119, 0.8);
}

.pet-item.selected {
  border: 2px solid white;
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
}